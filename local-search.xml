<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python手册-算法和数据结构</title>
    <link href="/2020/06/12/ython%E6%89%8B%E5%86%8C-%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/06/12/ython%E6%89%8B%E5%86%8C-%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h3 id="1、将序列分解为单独的变量（赋值）"><a href="#1、将序列分解为单独的变量（赋值）" class="headerlink" title="1、将序列分解为单独的变量（赋值）"></a>1、将序列分解为单独的变量（赋值）</h3><h4 id="1-1、问题"><a href="#1-1、问题" class="headerlink" title="1.1、问题"></a>1.1、问题</h4><p>有一个包含N个元素的元组或序列，现在将它分解为N个单独的变量</p><h4 id="1-2、解决方案"><a href="#1-2、解决方案" class="headerlink" title="1.2、解决方案"></a>1.2、解决方案</h4><p>简单的赋值操作来分解为单独的变量。</p><p>唯一的要求是变量的总数和结构要与序列相吻合。</p><pre><code class="hljs python">p = (<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)x,y = p</code></pre><pre><code class="hljs python">x</code></pre><pre><code>4</code></pre><pre><code class="hljs python">y</code></pre><pre><code>5</code></pre><pre><code class="hljs python">data = [<span class="hljs-string">'ACME'</span>,<span class="hljs-number">50</span>,<span class="hljs-number">91.1</span>,(<span class="hljs-number">2020</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>)]name,shares,price,date = dataname</code></pre><pre><code>&apos;ACME&apos;</code></pre><pre><code class="hljs python">date</code></pre><pre><code>(2020, 6, 9)</code></pre><pre><code class="hljs python">name,shares,price,(year,mon,day) = data</code></pre><pre><code class="hljs python">year</code></pre><pre><code>2020</code></pre><pre><code class="hljs python">day</code></pre><pre><code>9</code></pre><p>如果数量不匹配，会报错</p><pre><code class="hljs python">p = (<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)x,y,z = p</code></pre><pre><code>---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-10-6f98f1fa66f8&gt; in &lt;module&gt;      1 p = (4,5)----&gt; 2 x,y,z = pValueError: not enough values to unpack (expected 3, got 2)</code></pre><blockquote><p>不仅是元组和列表，只要对象可迭代，就可以执行分解操作，包括字符串、文件、迭代器以及生成器。</p></blockquote><pre><code class="hljs python">s = <span class="hljs-string">'Hello'</span>a,b,c,d,e = s</code></pre><pre><code class="hljs python">a</code></pre><pre><code>&apos;H&apos;</code></pre><blockquote><p>Python并没有提供特殊的语法来实现丢弃某些特定的值，可以选一个用不到的变量名，以此来作为要丢弃的值的名称。</p></blockquote><pre><code class="hljs python">data = [<span class="hljs-string">'ACME'</span>,<span class="hljs-number">50</span>,<span class="hljs-number">91.1</span>,(<span class="hljs-number">2020</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>)]_,shares,price,_ = data</code></pre><h3 id="2、从任意长度的可迭代对象分解元素-赋值"><a href="#2、从任意长度的可迭代对象分解元素-赋值" class="headerlink" title="2、从任意长度的可迭代对象分解元素(赋值)"></a>2、从任意长度的可迭代对象分解元素(赋值)</h3><h4 id="2-1、问题"><a href="#2-1、问题" class="headerlink" title="2.1、问题"></a>2.1、问题</h4><p>需要从某个可迭代对象中分解出N个元素，但是这个可迭代对象的长度可以超过N，这会导致出现“分解的值过多”的异常。</p><h4 id="2-2、解决方案"><a href="#2-2、解决方案" class="headerlink" title="2.2、解决方案"></a>2.2、解决方案</h4><p>Python的“*表达式”可以用来解决这个问题。</p><pre><code class="hljs python">record = (<span class="hljs-string">'Dave'</span>,<span class="hljs-string">'dave@example.com'</span>,<span class="hljs-string">'773-555-1212'</span>,<span class="hljs-string">'847-555-1212'</span>)name,email,*phone_numbers = record</code></pre><pre><code class="hljs python">name</code></pre><pre><code>&apos;Dave&apos;</code></pre><pre><code class="hljs python">phone_numbers</code></pre><pre><code>[&apos;773-555-1212&apos;, &apos;847-555-1212&apos;]</code></pre><h3 id="3、保存最后N个元素-队列"><a href="#3、保存最后N个元素-队列" class="headerlink" title="3、保存最后N个元素(队列)"></a>3、保存最后N个元素(队列)</h3><p>在迭代或是其他形式的处理过程中对最后几项记录做一个有限的历史纪录统计。</p><h4 id="3-1、解决方案"><a href="#3-1、解决方案" class="headerlink" title="3.1、解决方案"></a>3.1、解决方案</h4><p>使用队列，<code>collections.deque</code>的完美应用场景。</p><p>下面的代码对一系列文本行做简单的文本匹配操作，当发现有匹配时就输出点给钱的匹配行以及最后检查过的N行文本。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(lines,pattern,history = <span class="hljs-number">5</span>)</span>:</span>    pre_lines = deque(maxlen=history)    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:        <span class="hljs-keyword">yield</span> line,pre_lines    pre_lines.append(line)</code></pre><blockquote><p><code>deque(maxlen=N)</code>创建了一个固定长度的队列。当有新纪录加入队列而队列已满时会自动移除最老的那条记录。例如</p></blockquote><pre><code class="hljs python">q = deque(maxlen = <span class="hljs-number">3</span>)q.append(<span class="hljs-number">1</span>)q.append(<span class="hljs-number">2</span>)q.append(<span class="hljs-number">3</span>)</code></pre><pre><code class="hljs python">q</code></pre><pre><code>deque([1, 2, 3])</code></pre><pre><code class="hljs python">q.append(<span class="hljs-number">5</span>)</code></pre><pre><code class="hljs python">q</code></pre><pre><code>deque([2, 3, 5])</code></pre><blockquote><p>如果不指定队列的大小，就得到了一个无界限的对了，可以在两端执行添加和弹出操作。</p></blockquote><blockquote><p>从队列两端添加或者弹出元素的复杂度为O（1）。这和列表不同，当从列表的头部插入或移除 元素时，列表的时间复杂度为O(N)</p></blockquote><pre><code class="hljs python">p = deque()p.append(<span class="hljs-number">1</span>)p.append(<span class="hljs-number">2</span>)p.append(<span class="hljs-number">3</span>)p</code></pre><pre><code>deque([1, 2, 3])</code></pre><pre><code class="hljs python">p.append(<span class="hljs-number">4</span>)p</code></pre><pre><code>deque([1, 2, 3, 4])</code></pre><pre><code class="hljs python">p.appendleft(<span class="hljs-number">5</span>)p</code></pre><pre><code>deque([5, 1, 2, 3, 4])</code></pre><pre><code class="hljs python">p.pop()</code></pre><pre><code>4</code></pre><pre><code class="hljs python">p.popleft()</code></pre><pre><code>5</code></pre><h3 id="4、找到最大或最小的N个元素-堆"><a href="#4、找到最大或最小的N个元素-堆" class="headerlink" title="4、找到最大或最小的N个元素(堆)"></a>4、找到最大或最小的N个元素(堆)</h3><h4 id="4-1、问题"><a href="#4-1、问题" class="headerlink" title="4.1、问题"></a>4.1、问题</h4><p>在某个集合中找出最大或最小的N个元素。</p><h4 id="4-2、解决方案"><a href="#4-2、解决方案" class="headerlink" title="4.2、解决方案"></a>4.2、解决方案</h4><p>堆排序<code>heapq</code>模块中有两个函数——<code>nlargest()</code>和<code>nsmallest()</code>——正是我们所需要的。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapqnums = [<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">23</span>,<span class="hljs-number">7</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">18</span>,<span class="hljs-number">23</span>,<span class="hljs-number">42</span>,<span class="hljs-number">37</span>,<span class="hljs-number">2</span>]print(heapq.nlargest(<span class="hljs-number">3</span>,nums))print(heapq.nsmallest(<span class="hljs-number">3</span>,nums))</code></pre><pre><code>[42, 37, 23][-4, 1, 2]</code></pre><blockquote><p>这两个函数都可以接受一个参数key，从而允许他们工作在更加复杂的数据结构之上。例如：</p></blockquote><pre><code class="hljs python">protfo = [    &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'IBM'</span>,<span class="hljs-string">'shares'</span>:<span class="hljs-number">100</span>,<span class="hljs-string">'price'</span>:<span class="hljs-number">91.1</span>&#125;,    &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'AAPL'</span>,<span class="hljs-string">'shares'</span>:<span class="hljs-number">80</span>,<span class="hljs-string">'price'</span>:<span class="hljs-number">543.22</span>&#125;,    &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'FB'</span>,<span class="hljs-string">'shares'</span>:<span class="hljs-number">50</span>,<span class="hljs-string">'price'</span>:<span class="hljs-number">21.09</span>&#125;,    &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'HPQ'</span>,<span class="hljs-string">'shares'</span>:<span class="hljs-number">200</span>,<span class="hljs-string">'price'</span>:<span class="hljs-number">31.1</span>&#125;,    &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'YHO'</span>,<span class="hljs-string">'shares'</span>:<span class="hljs-number">35</span>,<span class="hljs-string">'price'</span>:<span class="hljs-number">16.1</span>&#125;,    &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'ACME'</span>,<span class="hljs-string">'shares'</span>:<span class="hljs-number">40</span>,<span class="hljs-string">'price'</span>:<span class="hljs-number">50.1</span>&#125;,    &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'TAOBAO'</span>,<span class="hljs-string">'shares'</span>:<span class="hljs-number">45</span>,<span class="hljs-string">'price'</span>:<span class="hljs-number">10.1</span>&#125;,    &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'JD'</span>,<span class="hljs-string">'shares'</span>:<span class="hljs-number">75</span>,<span class="hljs-string">'price'</span>:<span class="hljs-number">3.1</span>&#125;,]cheap = heapq.nsmallest(<span class="hljs-number">3</span>,protfo,key = <span class="hljs-keyword">lambda</span> s: s[<span class="hljs-string">'price'</span>])expensive = heapq.nlargest(<span class="hljs-number">3</span>,protfo,key = <span class="hljs-keyword">lambda</span> s: s[<span class="hljs-string">'price'</span>])</code></pre><pre><code class="hljs python">cheap</code></pre><pre><code>[{&apos;name&apos;: &apos;JD&apos;, &apos;shares&apos;: 75, &apos;price&apos;: 3.1}, {&apos;name&apos;: &apos;TAOBAO&apos;, &apos;shares&apos;: 45, &apos;price&apos;: 10.1}, {&apos;name&apos;: &apos;YHO&apos;, &apos;shares&apos;: 35, &apos;price&apos;: 16.1}]</code></pre><pre><code class="hljs python">expensive</code></pre><pre><code>[{&apos;name&apos;: &apos;AAPL&apos;, &apos;shares&apos;: 80, &apos;price&apos;: 543.22}, {&apos;name&apos;: &apos;IBM&apos;, &apos;shares&apos;: 100, &apos;price&apos;: 91.1}, {&apos;name&apos;: &apos;ACME&apos;, &apos;shares&apos;: 40, &apos;price&apos;: 50.1}]</code></pre><h3 id="5、实现优先级队列（堆）"><a href="#5、实现优先级队列（堆）" class="headerlink" title="5、实现优先级队列（堆）"></a>5、实现优先级队列（堆）</h3><h4 id="5-1、问题"><a href="#5-1、问题" class="headerlink" title="5.1、问题"></a>5.1、问题</h4><p>实现一个队列，以给定的优先级对元素排序，且每次pop操作都会返回优先级最高的那个元素。</p><h4 id="5-2、解决方案"><a href="#5-2、解决方案" class="headerlink" title="5.2、解决方案"></a>5.2、解决方案</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self._queue = []        self._index = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self,item,priority)</span>:</span>        heapq.heappush(self._queue,(-priority,self._index,item))        self._index += <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> heapq.heappop(self._queue)[<span class="hljs-number">-1</span>]</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 定义一个Item类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name)</span>:</span>        self.name = name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'Item(&#123;!r&#125;)'</span>.format(self.name)q = PriorityQueue()q.push(Item(<span class="hljs-string">'foo'</span>),<span class="hljs-number">1</span>)q.push(Item(<span class="hljs-string">'bar'</span>),<span class="hljs-number">5</span>)q.push(Item(<span class="hljs-string">'spam'</span>),<span class="hljs-number">4</span>)q.push(Item(<span class="hljs-string">'grok'</span>),<span class="hljs-number">1</span>)q.push(Item(<span class="hljs-string">'gk'</span>),<span class="hljs-number">6</span>)q.pop()</code></pre><pre><code>Item(&apos;gk&apos;)</code></pre><pre><code class="hljs python">q.pop()</code></pre><pre><code>Item(&apos;bar&apos;)</code></pre><blockquote><p>第一次执行pop()操作时返回的元素具有最高的优先级。相同优先级的返回顺序同插入到队列时的顺序相同</p></blockquote><h3 id="6、在字典中将键映射到多个值上（defaultdict）"><a href="#6、在字典中将键映射到多个值上（defaultdict）" class="headerlink" title="6、在字典中将键映射到多个值上（defaultdict）"></a>6、在字典中将键映射到多个值上（defaultdict）</h3><h4 id="6-1、问题"><a href="#6-1、问题" class="headerlink" title="6.1、问题"></a>6.1、问题</h4><p>一个能将键（key）映射到多个值的字典（即所谓的一键多值[multidict]）</p><h4 id="6-2、解决方案"><a href="#6-2、解决方案" class="headerlink" title="6.2、解决方案"></a>6.2、解决方案</h4><p>可以将这个多值保存到另一个容器如列表或稽核中。</p><pre><code class="hljs python">d = &#123;    <span class="hljs-string">'a'</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],    <span class="hljs-string">'b'</span>:[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]&#125;</code></pre><pre><code class="hljs python">d</code></pre><pre><code>{&apos;a&apos;: [1, 2, 3], &apos;b&apos;: [4, 5]}</code></pre><p>利用collections模块中的defaultdict类。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdictb = defaultdict(list)b[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">1</span>)b</code></pre><pre><code>defaultdict(list, {&apos;a&apos;: [1]})</code></pre><pre><code class="hljs python">b[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">2</span>)b[<span class="hljs-string">'b'</span>].append(<span class="hljs-number">1</span>)</code></pre><pre><code class="hljs python">b</code></pre><pre><code>defaultdict(list, {&apos;a&apos;: [1, 2], &apos;b&apos;: [1]})</code></pre><blockquote><p>原则上，构建一个一键多值字典是很容易的。但是如果试着对第一个值做初始化操作，就会变得杂乱，如需要判断这个键是否存在。使用defaultdict后，只需添加元素就可以了，不用在意这个键是否存在</p></blockquote><h3 id="7、让字典保持有序（OrderdDict双向链表）"><a href="#7、让字典保持有序（OrderdDict双向链表）" class="headerlink" title="7、让字典保持有序（OrderdDict双向链表）"></a>7、让字典保持有序（OrderdDict双向链表）</h3><h4 id="7-1、问题"><a href="#7-1、问题" class="headerlink" title="7.1、问题"></a>7.1、问题</h4><p>创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。</p><h4 id="7-2、解决方案"><a href="#7-2、解决方案" class="headerlink" title="7.2、解决方案"></a>7.2、解决方案</h4><p>使用collections模块中的OrderedDict类。当对字典做迭代时，严格按照元素初始添加的顺序进行。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDictd = OrderedDict()d[<span class="hljs-string">'foo'</span>] = <span class="hljs-number">1</span>d[<span class="hljs-string">'bar'</span>] = <span class="hljs-number">2</span>d[<span class="hljs-string">'spam'</span>] = <span class="hljs-number">4</span>d[<span class="hljs-string">'grok'</span>] = <span class="hljs-number">3</span>d</code></pre><pre><code>OrderedDict([(&apos;foo&apos;, 1), (&apos;bar&apos;, 2), (&apos;spam&apos;, 4), (&apos;grok&apos;, 3)])</code></pre><p>构建一个映射结构以便稍后对其做序列化或编码成另一种格式，如果想在进行JSON编码时精确控制各字段的顺序。</p><blockquote><p>OrderedDict的大小时普通字典的2倍多。</p></blockquote><h3 id="8、与字典有关的计算问题（zip（））"><a href="#8、与字典有关的计算问题（zip（））" class="headerlink" title="8、与字典有关的计算问题（zip（））"></a>8、与字典有关的计算问题（zip（））</h3><h4 id="8-1、问题"><a href="#8-1、问题" class="headerlink" title="8.1、问题"></a>8.1、问题</h4><p>在字典上对数据执行各式各样的计算（比如求最小值、最大值、排序等）</p><h4 id="8-2、解决方案"><a href="#8-2、解决方案" class="headerlink" title="8.2、解决方案"></a>8.2、解决方案</h4><pre><code class="hljs python">prices = &#123;    <span class="hljs-string">'ACME'</span>:<span class="hljs-number">45.23</span>,    <span class="hljs-string">'AAPL'</span>:<span class="hljs-number">612.75</span>,    <span class="hljs-string">'IBM'</span>:<span class="hljs-number">205.55</span>,    <span class="hljs-string">'HPQ'</span>:<span class="hljs-number">37.20</span>,    <span class="hljs-string">'FB'</span>:<span class="hljs-number">10.75</span>&#125;</code></pre><p>利用zip（）将字典的键和值反转过来。</p><pre><code class="hljs python">min_price = min(zip(prices.values(),prices.keys()))</code></pre><pre><code class="hljs python">min_price</code></pre><pre><code>(10.75, &apos;FB&apos;)</code></pre><blockquote><p>zip()创建了一个迭代器，他的内同只能被消费一次。</p></blockquote><h3 id="9、在两个字典中寻找相同点（keys-、items-集合操作）"><a href="#9、在两个字典中寻找相同点（keys-、items-集合操作）" class="headerlink" title="9、在两个字典中寻找相同点（keys()、items()集合操作）"></a>9、在两个字典中寻找相同点（keys()、items()集合操作）</h3><h4 id="9-1、问题"><a href="#9-1、问题" class="headerlink" title="9.1、问题"></a>9.1、问题</h4><p>有两个字典，找到他们中间可能相同的地方（相同的键、相同的值）。</p><h4 id="9-2、解决方案"><a href="#9-2、解决方案" class="headerlink" title="9.2、解决方案"></a>9.2、解决方案</h4><p>通过keys()或items()方法执行常见的集合操作即可。</p><pre><code class="hljs python">a = &#123;    <span class="hljs-string">'x'</span>:<span class="hljs-number">1</span>,    <span class="hljs-string">'y'</span>:<span class="hljs-number">2</span>,    <span class="hljs-string">'z'</span>:<span class="hljs-number">3</span>&#125;b=&#123;    <span class="hljs-string">'w'</span>:<span class="hljs-number">10</span>,    <span class="hljs-string">'x'</span>:<span class="hljs-number">11</span>,    <span class="hljs-string">'y'</span>:<span class="hljs-number">2</span>&#125;</code></pre><pre><code class="hljs python">a.keys()&amp;b.keys()</code></pre><pre><code>{&apos;x&apos;, &apos;y&apos;}</code></pre><pre><code class="hljs python">a.items()&amp;b.items()</code></pre><pre><code>{(&apos;y&apos;, 2)}</code></pre><h3 id="10、从序列中移除重复项且保持元素之间顺序不变"><a href="#10、从序列中移除重复项且保持元素之间顺序不变" class="headerlink" title="10、从序列中移除重复项且保持元素之间顺序不变"></a>10、从序列中移除重复项且保持元素之间顺序不变</h3><h4 id="10-1、问题"><a href="#10-1、问题" class="headerlink" title="10.1、问题"></a>10.1、问题</h4><p>去除序列中出现的重复元素，但仍然保持剩下的元素顺序不变。</p><h4 id="10-2、解决方案"><a href="#10-2、解决方案" class="headerlink" title="10.2、解决方案"></a>10.2、解决方案</h4><p>如果序列中的值是可哈希的，那么这个问题可以通过使用集合和生成器轻松解决。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dedupe</span><span class="hljs-params">(items)</span>:</span>    seen = set()    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:        <span class="hljs-keyword">if</span> item <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:            <span class="hljs-keyword">yield</span> item            seen.add(item)</code></pre><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>]list(dedupe(a))</code></pre><pre><code>[1, 5, 2, 9, 10]</code></pre><p>如果在不可哈希的对象（比如列表）序列中去除重复项，需要做如下修改</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dedupe</span><span class="hljs-params">(items,key=None)</span>:</span>    seen = set()    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:        val = item <span class="hljs-keyword">if</span> key <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> key(item)        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:            <span class="hljs-keyword">yield</span> item            seen.add(item)</code></pre><h3 id="11、对切片名命（slice-l-r-）"><a href="#11、对切片名命（slice-l-r-）" class="headerlink" title="11、对切片名命（slice(l,r)）"></a>11、对切片名命（slice(l,r)）</h3><h4 id="11-1、问题"><a href="#11-1、问题" class="headerlink" title="11.1、问题"></a>11.1、问题</h4><p>代码中都是切片的索引，难以阅读</p><h4 id="11-2、解决方案"><a href="#11-2、解决方案" class="headerlink" title="11.2、解决方案"></a>11.2、解决方案</h4><p>slice(l,r),从l到r固定取数据,后续使用别名即可</p><pre><code class="hljs python">s = <span class="hljs-string">'01234567890123456789199401234567891018'</span>year = slice(<span class="hljs-number">20</span>,<span class="hljs-number">24</span>)cost = int(s[year])</code></pre><pre><code class="hljs python">cost</code></pre><pre><code>1994</code></pre><pre><code class="hljs python">year.start</code></pre><pre><code>20</code></pre><pre><code class="hljs python">year.stop</code></pre><pre><code>24</code></pre><pre><code class="hljs python">year.step</code></pre><blockquote><p>slice(l,r),可以通过start、stop、step获取切片索引和步长</p></blockquote><h3 id="12、找出序列中出现次数最多的元素（Counter-）"><a href="#12、找出序列中出现次数最多的元素（Counter-）" class="headerlink" title="12、找出序列中出现次数最多的元素（Counter()）"></a>12、找出序列中出现次数最多的元素（Counter()）</h3><h4 id="12-1、问题"><a href="#12-1、问题" class="headerlink" title="12.1、问题"></a>12.1、问题</h4><p>有一个元素序列，想知道在序列中出现的次数最多的元素是什么。</p><h4 id="12-2、解决方案"><a href="#12-2、解决方案" class="headerlink" title="12.2、解决方案"></a>12.2、解决方案</h4><p>collections模块中的Counter类正是为此类问题所设计的。most_common()方法可以直接告诉我们答案</p><pre><code class="hljs python">words = [<span class="hljs-string">'look'</span>,<span class="hljs-string">'into'</span>,<span class="hljs-string">'eyes'</span>,<span class="hljs-string">'my'</span>,<span class="hljs-string">'eyes'</span>,<span class="hljs-string">'look'</span>,<span class="hljs-string">'into'</span>,<span class="hljs-string">'look'</span>,<span class="hljs-string">'my'</span>,<span class="hljs-string">'look'</span>,<span class="hljs-string">'eyes'</span>,<span class="hljs-string">'the'</span>,<span class="hljs-string">'eyes'</span>]</code></pre><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counterword_counts = Counter(words)top_two = word_counts.most_common(<span class="hljs-number">3</span>)</code></pre><pre><code class="hljs python">top_two</code></pre><pre><code>[(&apos;look&apos;, 4), (&apos;eyes&apos;, 4), (&apos;into&apos;, 2)]</code></pre><h3 id="13、通过公共键对字典列表排序-itemgetter"><a href="#13、通过公共键对字典列表排序-itemgetter" class="headerlink" title="13、通过公共键对字典列表排序(itemgetter)"></a>13、通过公共键对字典列表排序(itemgetter)</h3><h4 id="13-1、问题"><a href="#13-1、问题" class="headerlink" title="13.1、问题"></a>13.1、问题</h4><p>一个字典列表，想根据一个或多个字典中的值来对列表排序</p><h4 id="13-2、解决方案"><a href="#13-2、解决方案" class="headerlink" title="13.2、解决方案"></a>13.2、解决方案</h4><p>利用operator模块中的itemgetter函数对这类结构进行排序是非常简单的。</p><pre><code class="hljs python">rows = [    &#123;<span class="hljs-string">'fname'</span>:<span class="hljs-string">'Brian'</span>,<span class="hljs-string">'lname'</span>:<span class="hljs-string">'Jones'</span>,<span class="hljs-string">'uid'</span>:<span class="hljs-number">1003</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>:<span class="hljs-string">'Drian'</span>,<span class="hljs-string">'lname'</span>:<span class="hljs-string">'Jones'</span>,<span class="hljs-string">'uid'</span>:<span class="hljs-number">1002</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>:<span class="hljs-string">'Crian'</span>,<span class="hljs-string">'lname'</span>:<span class="hljs-string">'Jones'</span>,<span class="hljs-string">'uid'</span>:<span class="hljs-number">1001</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>:<span class="hljs-string">'Arian'</span>,<span class="hljs-string">'lname'</span>:<span class="hljs-string">'Jones'</span>,<span class="hljs-string">'uid'</span>:<span class="hljs-number">1004</span>&#125;,]</code></pre><p>根据所有字典中共有的字段来对这些记录排序是非常简单的。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetterrows_by_fname = sorted(rows,key=itemgetter(<span class="hljs-string">'fname'</span>))rows_by_uid = sorted(rows,key = itemgetter(<span class="hljs-string">'uid'</span>))</code></pre><pre><code class="hljs python">rows_by_fname</code></pre><pre><code>[{&apos;fname&apos;: &apos;Arian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1004}, {&apos;fname&apos;: &apos;Brian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1003}, {&apos;fname&apos;: &apos;Crian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1001}, {&apos;fname&apos;: &apos;Drian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1002}]</code></pre><pre><code class="hljs python">rows_by_uid</code></pre><pre><code>[{&apos;fname&apos;: &apos;Crian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1001}, {&apos;fname&apos;: &apos;Drian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1002}, {&apos;fname&apos;: &apos;Brian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1003}, {&apos;fname&apos;: &apos;Arian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1004}]</code></pre><h3 id="14、对不原生支持比较操作的对象排序（sorted（））"><a href="#14、对不原生支持比较操作的对象排序（sorted（））" class="headerlink" title="14、对不原生支持比较操作的对象排序（sorted（））"></a>14、对不原生支持比较操作的对象排序（sorted（））</h3><h4 id="14-1、问题"><a href="#14-1、问题" class="headerlink" title="14.1、问题"></a>14.1、问题</h4><p>在同一个类的实例之间做排序，但是他们并不原生支持比较操作。</p><h4 id="14-2、解决方案"><a href="#14-2、解决方案" class="headerlink" title="14.2、解决方案"></a>14.2、解决方案</h4><p>使用<code>sorted()</code>函数可接受一个用来传递可调用对象（callable）的参数key，而该可调用对象会返回待排序对象中的某些值，<code>sorted</code>则利用这些值来比较对象。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,user_id)</span>:</span>        self.user_id = user_id    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'User(&#123;&#125;)'</span>.format(self.user_id)</code></pre><pre><code class="hljs python">users = [User(<span class="hljs-number">20</span>),User(<span class="hljs-number">10</span>),User(<span class="hljs-number">99</span>)]</code></pre><pre><code class="hljs python">users</code></pre><pre><code>[User(20), User(10), User(99)]</code></pre><pre><code class="hljs python">sorted(users)</code></pre><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-4-3fc69e0271ff&gt; in &lt;module&gt;----&gt; 1 sorted(users)TypeError: &apos;&lt;&apos; not supported between instances of &apos;User&apos; and &apos;User&apos;</code></pre><pre><code class="hljs python">sorted(users,key = <span class="hljs-keyword">lambda</span> u: u.user_id)</code></pre><pre><code>[User(10), User(20), User(99)]</code></pre><h3 id="15、根据字段将记录分组（groupby-）"><a href="#15、根据字段将记录分组（groupby-）" class="headerlink" title="15、根据字段将记录分组（groupby()）"></a>15、根据字段将记录分组（groupby()）</h3><h4 id="15-1、问题"><a href="#15-1、问题" class="headerlink" title="15.1、问题"></a>15.1、问题</h4><p>有一系列的字典或对象实例，我们根据某个特定的字段（比如日期）来分组迭代数据。</p><h4 id="15-2、解决方案"><a href="#15-2、解决方案" class="headerlink" title="15.2、解决方案"></a>15.2、解决方案</h4><p><code>itertools.groupby()</code>函数在对数据进行分组时特别有用。</p><pre><code class="hljs python">rows = [    &#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'5412 n CLARK'</span>,<span class="hljs-string">'date'</span>:<span class="hljs-string">'07/01/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'5148 n CLARK'</span>,<span class="hljs-string">'date'</span>:<span class="hljs-string">'07/04/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'5800 n CLARK'</span>,<span class="hljs-string">'date'</span>:<span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'2122 n CLARK'</span>,<span class="hljs-string">'date'</span>:<span class="hljs-string">'07/03/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'5645 n CLARK'</span>,<span class="hljs-string">'date'</span>:<span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'1060 n CLARK'</span>,<span class="hljs-string">'date'</span>:<span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'4801 n CLARK'</span>,<span class="hljs-string">'date'</span>:<span class="hljs-string">'07/01/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'1039 n CLARK'</span>,<span class="hljs-string">'date'</span>:<span class="hljs-string">'07/04/2012'</span>&#125;,]</code></pre><p>先以目标字段对序列排序，然后使用groupby()</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> groupbyrows.sort(key = itemgetter(<span class="hljs-string">'date'</span>))</code></pre><pre><code class="hljs python">rows</code></pre><pre><code>[{&apos;address&apos;: &apos;5412 n CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;}, {&apos;address&apos;: &apos;4801 n CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;}, {&apos;address&apos;: &apos;5800 n CLARK&apos;, &apos;date&apos;: &apos;07/02/2012&apos;}, {&apos;address&apos;: &apos;5645 n CLARK&apos;, &apos;date&apos;: &apos;07/02/2012&apos;}, {&apos;address&apos;: &apos;1060 n CLARK&apos;, &apos;date&apos;: &apos;07/02/2012&apos;}, {&apos;address&apos;: &apos;2122 n CLARK&apos;, &apos;date&apos;: &apos;07/03/2012&apos;}, {&apos;address&apos;: &apos;5148 n CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;}, {&apos;address&apos;: &apos;1039 n CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;}]</code></pre><pre><code class="hljs python"><span class="hljs-keyword">for</span> date,items <span class="hljs-keyword">in</span> groupby(rows,key = itemgetter(<span class="hljs-string">'date'</span>)):    print(date)</code></pre><pre><code>07/01/201207/02/201207/03/201207/04/2012</code></pre><pre><code class="hljs python"><span class="hljs-keyword">for</span> date,items <span class="hljs-keyword">in</span> groupby(rows,key = itemgetter(<span class="hljs-string">'date'</span>)):    print(date)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items:        print(<span class="hljs-string">' '</span>,i)</code></pre><pre><code>07/01/2012  {&apos;address&apos;: &apos;5412 n CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;}  {&apos;address&apos;: &apos;4801 n CLARK&apos;, &apos;date&apos;: &apos;07/01/2012&apos;}07/02/2012  {&apos;address&apos;: &apos;5800 n CLARK&apos;, &apos;date&apos;: &apos;07/02/2012&apos;}  {&apos;address&apos;: &apos;5645 n CLARK&apos;, &apos;date&apos;: &apos;07/02/2012&apos;}  {&apos;address&apos;: &apos;1060 n CLARK&apos;, &apos;date&apos;: &apos;07/02/2012&apos;}07/03/2012  {&apos;address&apos;: &apos;2122 n CLARK&apos;, &apos;date&apos;: &apos;07/03/2012&apos;}07/04/2012  {&apos;address&apos;: &apos;5148 n CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;}  {&apos;address&apos;: &apos;1039 n CLARK&apos;, &apos;date&apos;: &apos;07/04/2012&apos;}</code></pre><blockquote><p><code>groupby()</code>只能检查连续的项，不首先排序的话，将无法按照所想的方式来对记录分组</p></blockquote><h3 id="16、筛选序列中的元素-列表推导式、生成式，迭代式"><a href="#16、筛选序列中的元素-列表推导式、生成式，迭代式" class="headerlink" title="16、筛选序列中的元素(列表推导式、生成式，迭代式)"></a>16、筛选序列中的元素(列表推导式、生成式，迭代式)</h3><h4 id="16-1、问题"><a href="#16-1、问题" class="headerlink" title="16.1、问题"></a>16.1、问题</h4><p>序列中含有一些数据，需要提取出其中的值或根据某些标准对序列做删减。</p><h4 id="16-2、解决方案"><a href="#16-2、解决方案" class="headerlink" title="16.2、解决方案"></a>16.2、解决方案</h4><p>列表推导式</p><pre><code class="hljs python">mylist = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">-7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>][n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> mylist <span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">0</span>]</code></pre><pre><code>[1, 4, 10, 2, 3]</code></pre><blockquote><p>列表推导式的潜在缺点是如果原始输入非常大的话，就可能会产生一个庞大的结果。</p></blockquote><p>生成器表达式通过迭代产生筛选结果。</p><pre><code class="hljs python">pos =(n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> mylist <span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">0</span>)pos</code></pre><pre><code>&lt;generator object &lt;genexpr&gt; at 0x00000230F1243318&gt;</code></pre><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> pos:    print(x,end = <span class="hljs-string">' '</span>)</code></pre><pre><code>1 4 10 2 3 </code></pre><p>有时候筛选的标准没法简单地表示在列表推导式或生成器表达式中。可使用内建的filter()函数处理。</p><pre><code class="hljs python">values = [<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'-3'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'N/A'</span>,<span class="hljs-string">'5'</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_int</span><span class="hljs-params">(val)</span>:</span>    <span class="hljs-keyword">try</span>:        x = int(val)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">except</span> ValueError:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>ivals = list(filter(is_int,values))print(ivals)</code></pre><pre><code>[&apos;1&apos;, &apos;2&apos;, &apos;-3&apos;, &apos;4&apos;, &apos;5&apos;]</code></pre><blockquote><p><code>filter()</code>创建了一个迭代器，因此如果想要列表形式的结果，请确保加上list()</p></blockquote><blockquote><p><code>filter(func,list)</code>遍历list中的每个值</p></blockquote><h3 id="17、从字典中提取子集（字典推导式）"><a href="#17、从字典中提取子集（字典推导式）" class="headerlink" title="17、从字典中提取子集（字典推导式）"></a>17、从字典中提取子集（字典推导式）</h3><h4 id="17-1、问题"><a href="#17-1、问题" class="headerlink" title="17.1、问题"></a>17.1、问题</h4><p>创建一个字典，其本身是另一个字典的子集。</p><h4 id="17-2、解决方案"><a href="#17-2、解决方案" class="headerlink" title="17.2、解决方案"></a>17.2、解决方案</h4><p>利用字典推导式。</p><pre><code class="hljs python">prices = &#123;    <span class="hljs-string">'ACME'</span>:<span class="hljs-number">45.23</span>,    <span class="hljs-string">'AAPL'</span>:<span class="hljs-number">612.78</span>,    <span class="hljs-string">'IBM'</span>:<span class="hljs-number">205.55</span>,    <span class="hljs-string">'HPQ'</span>:<span class="hljs-number">37.20</span>,    <span class="hljs-string">'FB'</span>:<span class="hljs-number">10.75</span>&#125;</code></pre><pre><code class="hljs python">p1 = &#123;key:value <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> prices.items() <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">200</span>&#125;p1</code></pre><pre><code>{&apos;AAPL&apos;: 612.78, &apos;IBM&apos;: 205.55}</code></pre><pre><code class="hljs python">tech_names = &#123;<span class="hljs-string">'AAPL'</span>,<span class="hljs-string">'IBM'</span>&#125;p2 = &#123;key:value <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> prices.items() <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> tech_names&#125;p2</code></pre><pre><code>{&apos;AAPL&apos;: 612.78, &apos;IBM&apos;: 205.55}</code></pre><h3 id="18、将名称映射到序列的元素中（collections-namedtuple（名命元组））"><a href="#18、将名称映射到序列的元素中（collections-namedtuple（名命元组））" class="headerlink" title="18、将名称映射到序列的元素中（collections.namedtuple（名命元组））"></a>18、将名称映射到序列的元素中（<code>collections.namedtuple</code>（名命元组））</h3><h4 id="18-1、问题"><a href="#18-1、问题" class="headerlink" title="18.1、问题"></a>18.1、问题</h4><p>代码是通过位置（即索引、下标）来访问列表和元组的，但有时这会使代码变得难以阅读。希望可以通过名称以及相应的字段，减少结构中对位置的依赖性。</p><h4 id="18-2、解决方案"><a href="#18-2、解决方案" class="headerlink" title="18.2、解决方案"></a>18.2、解决方案</h4><p><code>collections.namedtuple</code>（名命元组）只增加极小的开销就提供了这些便利。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtupleSubscriber = namedtuple(<span class="hljs-string">'Subscriber'</span>,[<span class="hljs-string">'addr'</span>,<span class="hljs-string">'joined'</span>])sub = Subscriber(<span class="hljs-string">'715182260@qq.com'</span>,joined = <span class="hljs-string">'2012-10-19'</span>)</code></pre><pre><code class="hljs python">sub</code></pre><pre><code>Subscriber(addr=&apos;715182260@qq.com&apos;, joined=&apos;2012-10-19&apos;)</code></pre><blockquote><p>相对于字典有更小的开销，且不能改变</p></blockquote><h3 id="19、同时对数据做转换和换算（在函数参数中使用生成器）"><a href="#19、同时对数据做转换和换算（在函数参数中使用生成器）" class="headerlink" title="19、同时对数据做转换和换算（在函数参数中使用生成器）"></a>19、同时对数据做转换和换算（在函数参数中使用生成器）</h3><h4 id="19-1、问题"><a href="#19-1、问题" class="headerlink" title="19.1、问题"></a>19.1、问题</h4><p>需要调用一个换算（reduction）函数（例如sum()、min()、max()）,但首先得对数据做转换或筛选》</p><h4 id="19-2、解决方案"><a href="#19-2、解决方案" class="headerlink" title="19.2、解决方案"></a>19.2、解决方案</h4><p>在函数参数中使用生成器表达式。</p><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]s=sum(x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums)s</code></pre><pre><code>55</code></pre><h3 id="20、将多个映射合并为单个映射（collections-ChainMap）"><a href="#20、将多个映射合并为单个映射（collections-ChainMap）" class="headerlink" title="20、将多个映射合并为单个映射（collections.ChainMap）"></a>20、将多个映射合并为单个映射（collections.ChainMap）</h3><h4 id="20-1、问题"><a href="#20-1、问题" class="headerlink" title="20.1、问题"></a>20.1、问题</h4><p>有多个映射，想在逻辑上将他们合并为一个单独的映射结构，以此执行某些特定的操作，比如查找值或检查键是否存在。</p><h4 id="20-2解决方案"><a href="#20-2解决方案" class="headerlink" title="20.2解决方案"></a>20.2解决方案</h4><pre><code class="hljs python">a = &#123;<span class="hljs-string">'x'</span>:<span class="hljs-number">1</span>,<span class="hljs-string">'z'</span>:<span class="hljs-number">3</span>&#125;b = &#123;<span class="hljs-string">'y'</span>:<span class="hljs-number">2</span>,<span class="hljs-string">'z'</span>:<span class="hljs-number">4</span>&#125;</code></pre><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMapc = ChainMap(a,b)</code></pre><pre><code class="hljs python">c[<span class="hljs-string">'x'</span>]</code></pre><pre><code>1</code></pre><pre><code class="hljs python">c[<span class="hljs-string">'y'</span>]</code></pre><pre><code>2</code></pre><pre><code class="hljs python">c[<span class="hljs-string">'z'</span>]</code></pre><pre><code>3</code></pre><blockquote><p>ChainMap可接受多个映射然后再逻辑上使他们表现为一个单独的映射结构。但是，这些映射在字面上并不会合并在一起。相反，ChainMap只是简单维护一个记录底层映射关系的列表，然后重定义常见的字典操作来扫描这个列表。</p></blockquote><blockquote><p>update()方法将多个字典合并在一起。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python经典编程</title>
    <link href="/2020/06/10/ython%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/06/10/ython%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h2><p>一个三位数，如果个，十，百位的数字的三次方之和等于它本身，那么他就是一个水仙花数</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shui</span><span class="hljs-params">(num)</span>:</span>    ge = num%<span class="hljs-number">10</span>    bai = num//<span class="hljs-number">100</span>    shi = num//<span class="hljs-number">10</span>-bai*<span class="hljs-number">10</span>    <span class="hljs-keyword">if</span> ge**<span class="hljs-number">3</span>+bai**<span class="hljs-number">3</span>+shi**<span class="hljs-number">3</span> ==num:        print(num)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>):    shui(i)</code></pre><pre><code>153370371407</code></pre><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code class="hljs python"><span class="hljs-comment"># for循环</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibs</span><span class="hljs-params">(nums)</span>:</span>    a = [<span class="hljs-number">1</span>]    <span class="hljs-keyword">if</span> nums &lt;=<span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span>    <span class="hljs-keyword">elif</span> nums == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> a    <span class="hljs-keyword">elif</span> nums == <span class="hljs-number">2</span>:        a.append(<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> a    <span class="hljs-keyword">elif</span> nums&gt;<span class="hljs-number">2</span>:        a.append(<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nums<span class="hljs-number">-2</span>):            a.append(a[i]+a[i+<span class="hljs-number">1</span>])        <span class="hljs-keyword">return</span> afibs(<span class="hljs-number">10</span>)</code></pre><pre><code>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 迭代</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibs_dei</span><span class="hljs-params">(nums)</span>:</span>    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt; nums &lt;=<span class="hljs-number">2</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">elif</span> nums&gt;<span class="hljs-number">2</span>:        <span class="hljs-keyword">return</span> fibs_dei(nums<span class="hljs-number">-1</span>)+fibs_dei(nums<span class="hljs-number">-2</span>)fibs_dei(<span class="hljs-number">10</span>)</code></pre><pre><code>55</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 加缓存，</span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<span class="hljs-meta">@lru_cache()</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibs_der</span><span class="hljs-params">(nums)</span>:</span>    <span class="hljs-keyword">if</span> nums&lt;= <span class="hljs-number">2</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> fibs_der(nums<span class="hljs-number">-1</span>)+fibs_der(nums<span class="hljs-number">-2</span>)print(fibs_der(<span class="hljs-number">10</span>))</code></pre><pre><code>55</code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度O（n),空间复杂度O(0</p><pre><code class="hljs python">a = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(nums)</span>:</span>    <span class="hljs-comment"># 循环N-1次</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)):        <span class="hljs-comment"># 执行前检查排序是否完成</span>        flag=<span class="hljs-literal">True</span>        <span class="hljs-comment"># 遍历比较每个元素与下一个元素值大小</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(nums)-i):            <span class="hljs-keyword">if</span> nums[j]&gt;nums[j+<span class="hljs-number">1</span>]:                nums[j],nums[j+<span class="hljs-number">1</span>]=nums[j+<span class="hljs-number">1</span>],nums[j]                <span class="hljs-comment"># 有要排序的就赋值为False</span>                flag = <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> flag:            <span class="hljs-keyword">break</span>bubble_sort(a)</code></pre><pre><code class="hljs python">a</code></pre><pre><code>[0, 1, 2, 3, 4, 5, 7, 8, 9]</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code class="hljs python">a = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select_sort</span><span class="hljs-params">(nums)</span>:</span>    <span class="hljs-comment"># 循环N-1次</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)):        <span class="hljs-comment"># 初始化选择的下标</span>        index = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)-i+<span class="hljs-number">1</span>):            <span class="hljs-keyword">if</span> nums[index] &lt; nums[j]:                index = j        <span class="hljs-comment"># 如果一轮顺序有变化，交换</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> index == j:            nums[index],nums[j] = nums[j],nums[index]select_sort(a)a</code></pre><pre><code>[0, 1, 2, 3, 4, 5, 7, 8, 9]</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(arr)</span>:</span>    <span class="hljs-comment"># 迭代N-1次</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(arr)):        <span class="hljs-comment"># 挑出待排序的元素</span>        temp,j = arr[i],i        <span class="hljs-comment"># 待排序元素与已排序元素进行比较，若小就进行插入，否则放在最后</span>        <span class="hljs-keyword">while</span> j&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> temp&lt;arr[j<span class="hljs-number">-1</span>]:            arr[j] = arr[j<span class="hljs-number">-1</span>]            j = j<span class="hljs-number">-1</span>        arr[j] = temp</code></pre><pre><code class="hljs python">b = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]insertSort(b)b</code></pre><pre><code>[0, 1, 2, 3, 4, 5, 7, 8, 9]</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code class="hljs python"><span class="hljs-comment"># 一次排序</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">one_sort</span><span class="hljs-params">(arr,l,r)</span>:</span>    <span class="hljs-comment"># 取最后一个值做标准</span>    pat = arr[r]    <span class="hljs-comment"># 慢指针，确定小于pat的值</span>    i = l<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(l,r):        <span class="hljs-comment"># 当arr[j]大于pat，慢指针i不做操作，快指针j继续遍历</span>        <span class="hljs-comment"># 反之，慢指针先向右移动1，交换快慢指针的值，即将快指针的值移动到前面</span>        <span class="hljs-keyword">if</span> arr[j]&lt;=pat:            i+=<span class="hljs-number">1</span>            arr[i],arr[j]=arr[j],arr[i]    arr[i+<span class="hljs-number">1</span>],arr[r] = arr[r],arr[i+<span class="hljs-number">1</span>]    <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(arr,l,r)</span>:</span>    <span class="hljs-keyword">if</span> l&lt;r:        q = one_sort(arr,l,r)        <span class="hljs-comment"># 左分治，不断迭代</span>        quick_sort(arr,l,q<span class="hljs-number">-1</span>)        <span class="hljs-comment"># 右分治，不断迭代</span>        quick_sort(arr,q+<span class="hljs-number">1</span>,r)d = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]quick_sort(d,<span class="hljs-number">0</span>,len(d)<span class="hljs-number">-1</span>)d</code></pre><pre><code>[0, 1, 2, 3, 4, 5, 7, 8, 9]</code></pre><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希即Python中的映射类型，字典和集合，键值唯一，查找效率高，序列（列表、元祖、字符串）的元素查找时间复杂度是O(n)，而字典和集合的查找只需要O(1)。<br>因此哈希在列表问题中主要有两种作用：</p><ul><li>去重</li><li>优化查找效率</li></ul><h3 id="列表去重"><a href="#列表去重" class="headerlink" title="列表去重"></a>列表去重</h3><p>列表去重在不考虑顺序的情况下可以直接使用set()转换（转换后会自动排序），需要保持顺序可以使用字典构建的fromkeys()方法，利用字典键值的唯一性去重。</p><p>l = [2,1,2,3,4,5,6,6,5,4,3,2,1]</p><h3 id="列表分组"><a href="#列表分组" class="headerlink" title="列表分组"></a>列表分组</h3><p>一串字母数字组合的字符串，找出相同的字母或数字，并按照个数排序。</p><p>l = [1,2,3,’a’,’b’,’c’,1,2,’a’,’b’,3,’c’,’d’,’a’,’b’,1]</p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>l=[1,2,3,4,5,6,7,8] 数据不重复，target=6，快速找出数组中两个元素之和等于target 的数组下标。</p><p>注意，不要使用双重循环，暴力加和来和target对比，正确的做法是单层循环，然后查找target与当前值的差，是否存在于列表中。<br>但是由于列表的in查询时间复杂度是O(n)，即隐含了一层循环，这样效率其实和双重循环是一样的，都是O(n^2)。<br>这里就可以使用哈希来优化查询差值是否在列表中操作，将O(n)降为O(1)，因此总体的效率就会变成O(n^2)-&gt;O(n)。</p><h2 id="递归问题"><a href="#递归问题" class="headerlink" title="递归问题"></a>递归问题</h2><p>递归是一种循环调用自身的函数。可以用于解决以下高频问题：</p><ul><li>阶乘</li><li>斐波那切数列</li><li>跳台阶、变态跳台阶</li><li>快速排序</li><li>二分查找</li><li>二叉树深度遍历（前序、中序、后序）</li><li>求二叉树深度</li><li>平衡二叉树判断</li><li>判断两颗树是否相同</li></ul><p>递归是一种分层推导解决问题的方法，是一种非常重要的解决问题的思想。递归可快速将问题层级化，简单化，只需要考虑出口和每层的推导即可。<br>如阶乘，要想求n!，只需要知道前一个数的阶乘(n-1)!，然后乘以n即可，因此问题可以转为求上一个数的阶乘，依次向前，直到第一个数。<br>举个通俗的例子：<br>A欠你10万，但是他没那么多钱，B欠A 8万，C欠B 7万 C现在有钱。因此你要逐层找到C，一层一层还钱，最后你才能拿到属于你的10万。</p><p>编写递归函数有两个要点：</p><ul><li><p>出口条件，可以不止一个</p></li><li><p>推导方法（已知上一个结果怎么推导当前结果）</p></li></ul><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>求n的阶乘</p><ul><li><p>出口：n = 1 时，返回1</p></li><li><p>推导：(n-1)层的结果 * n</p></li></ul><h3 id="跳台阶、变态跳台阶"><a href="#跳台阶、变态跳台阶" class="headerlink" title="跳台阶、变态跳台阶"></a>跳台阶、变态跳台阶</h3><ul><li><p>跳台阶：一只青蛙，一次可以跳上1阶，也可以跳上2阶，问跳上n阶有多少种跳法。</p></li><li><p>变态跳台阶：一只青蛙，一次可以跳上1阶，可以一次跳上n阶，为跳上n阶有多少种跳法。</p></li></ul><p>跳台阶实际上就是一个从第二位开始的斐波那切数列：1 2 3 5 8 13 …</p><ul><li><p>出口：n &lt;= 2，返回n（即1时返回1，2时返回2）</p></li><li><p>推导：(n-1)层的结果 + (n-2)层的结果</p></li></ul><p>变态跳台阶只是推导方式不同，每一层的结果是上一层跳法的2倍。</p><ul><li><p>出口：n &lt;= 2，返回n</p></li><li><p>推导：(n-1)层的结果 * 2</p></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找需要序列首先有序。思想是先用序列中间数和目标值对比，如果目标值小，则从前半部分（小于中间数）重复此查找，否则从后半部分重复此查找。</p><ul><li><p>出口1：中间数和目标数相同，返回中间数下标</p></li><li><p>出口2：列表为空，返回未找到</p></li><li><p>推导：</p></li></ul><h3 id="全排序"><a href="#全排序" class="headerlink" title="全排序"></a>全排序</h3><p>举个例子，比如你要对a,b,c三个字符进行全排列，那么它的全排列有abc,acb,bac,bca,cba,cab这六种可能，你们想想你们是如何得出这六种可能的。没错！就是当指针指向第一个元素a时，它可以是其本身a(即和自己进行交换)，还可以和b，c进行交换，故有3种可能，当第一个元素a确定以后，指针移向第二位置，第二个位置可以和其本身b及其后的元素c进行交换，又可以形成两种排列，当指针指向第三个元素c的时候，这个时候其后没有元素了，此时，则确定了一组排列，输出。但是每次输出后要把数组恢复为原来的样子。</p><p>简单来说，它的思想即为，确定第1位，对n-1位进行全排列，确定第二位，对n-2位进行全排列。。。显然，这是一种递归的思想。</p><ul><li>出口：position==end</li><li>推导：</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">all_sort</span><span class="hljs-params">(arr,position,end)</span>:</span>    <span class="hljs-keyword">if</span> position == end:        print(arr)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(position,end):            arr[i],arr[position]=arr[position],arr[i]            all_sort(arr,position+<span class="hljs-number">1</span>,end)            arr[i],arr[position]=arr[position],arr[i]a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]all_sort(a,<span class="hljs-number">0</span>,len(a))</code></pre><pre><code>[1, 2, 3][1, 3, 2][2, 1, 3][2, 3, 1][3, 2, 1][3, 1, 2]</code></pre><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程顺序打印1-10"><a href="#多线程顺序打印1-10" class="headerlink" title="多线程顺序打印1-10"></a>多线程顺序打印1-10</h3><pre><code class="hljs python"><span class="hljs-comment"># 控制多线程的执行顺序</span><span class="hljs-keyword">import</span> threading<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ou</span><span class="hljs-params">(num)</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, num):        lock1.acquire()        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:            print(i,end=<span class="hljs-string">' '</span>)        lock2.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ji</span><span class="hljs-params">(num)</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, num):        lock2.acquire()        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:            print(i,end=<span class="hljs-string">' '</span>)        lock1.release()<span class="hljs-comment"># 定义两个互斥锁，锁一先不加，保证先执行线程一</span>lock1 = threading.Lock()lock2 = threading.Lock()lock2.acquire()<span class="hljs-comment"># 定义两个线程</span>t1 = threading.Thread(target=ou, args=(<span class="hljs-number">10</span>,), name=<span class="hljs-string">'线程一'</span>)t2 = threading.Thread(target=ji, args=(<span class="hljs-number">10</span>,), name=<span class="hljs-string">'线程二'</span>)t1.start()t2.start()</code></pre><pre><code>0 1 2 3 4 5 6 7 8 9 </code></pre><pre><code class="hljs python"></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python经典题</title>
    <link href="/2020/06/10/ython%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
    <url>/2020/06/10/ython%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一行代码实现1–100之和"><a href="#一行代码实现1–100之和" class="headerlink" title="一行代码实现1–100之和"></a>一行代码实现1–100之和</h2><p>内置函数<code>sum()</code></p><pre><code class="hljs python">sum(range(<span class="hljs-number">0</span>,<span class="hljs-number">101</span>))</code></pre><pre><code>5050</code></pre><h2 id="在函数内部修改全局变量"><a href="#在函数内部修改全局变量" class="headerlink" title="在函数内部修改全局变量"></a>在函数内部修改全局变量</h2><p><code>global</code>引入全局变量进行修改</p><pre><code class="hljs python">a = <span class="hljs-number">5</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mod</span><span class="hljs-params">()</span>:</span>    b = <span class="hljs-number">1</span>+a    print(b)mod()</code></pre><pre><code>6</code></pre><pre><code class="hljs python">a = <span class="hljs-number">5</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mod</span><span class="hljs-params">()</span>:</span>    a=a+<span class="hljs-number">1</span>    print(a)mod()</code></pre><pre><code>---------------------------------------------------------------------------UnboundLocalError                         Traceback (most recent call last)&lt;ipython-input-10-72e4f762a7e9&gt; in &lt;module&gt;      3     a=a+1      4     print(a)----&gt; 5 mod()&lt;ipython-input-10-72e4f762a7e9&gt; in mod()      1 a = 5      2 def mod():----&gt; 3     a=a+1      4     print(a)      5 mod()UnboundLocalError: local variable &apos;a&apos; referenced before assignment</code></pre><blockquote><p>可以直接引用但无法进行修改</p></blockquote><pre><code class="hljs python">a = <span class="hljs-number">5</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mod</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">global</span> a    a=a+<span class="hljs-number">1</span>    print(a)mod()</code></pre><pre><code>6</code></pre><h2 id="字典删除键和合并两个字典"><a href="#字典删除键和合并两个字典" class="headerlink" title="字典删除键和合并两个字典"></a>字典删除键和合并两个字典</h2><p><code>del</code>删除、<code>update</code>合并</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'guokai'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-number">18</span>&#125;dic</code></pre><pre><code>{&apos;name&apos;: &apos;guokai&apos;, &apos;age&apos;: 18}</code></pre><pre><code class="hljs python"><span class="hljs-keyword">del</span> dic[<span class="hljs-string">'name'</span>]dic</code></pre><pre><code>{&apos;age&apos;: 18}</code></pre><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">'其他'</span>:<span class="hljs-string">'其他'</span>&#125;dic1</code></pre><pre><code>{&apos;其他&apos;: &apos;其他&apos;}</code></pre><pre><code class="hljs python">dic.update(dic1)dic</code></pre><pre><code>{&apos;age&apos;: 18, &apos;其他&apos;: &apos;其他&apos;}</code></pre><h2 id="GIL全局解释锁"><a href="#GIL全局解释锁" class="headerlink" title="GIL全局解释锁"></a>GIL全局解释锁</h2><ul><li>多线程线程竞争</li><li>一个线程运行python程序会霸占python解释器（加一把锁及GIL）</li><li>该线程运行完成后或碰到耗时操作，解释器打开</li></ul><h2 id="python实现列表去重的方法"><a href="#python实现列表去重的方法" class="headerlink" title="python实现列表去重的方法"></a>python实现列表去重的方法</h2><p>利用<code>set</code>集合元素的唯一性将<code>list</code>转为<code>set</code>干掉重复元素，再转会<code>list</code></p><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]a = set(list1)a</code></pre><pre><code>{1, 2, 3, 4}</code></pre><pre><code class="hljs python">list1 = list(a)list1</code></pre><pre><code>[1, 2, 3, 4]</code></pre><h2 id="fun-args-kwargs-中的-args-kwargs什么意思？"><a href="#fun-args-kwargs-中的-args-kwargs什么意思？" class="headerlink" title="fun( *args,**kwargs)中的*args,**kwargs什么意思？"></a>fun( *args,**kwargs)中的*args,**kwargs什么意思？</h2><ul><li>不确定传入参数的数量时可以用*args或者**kwargs</li><li>一个*为值类型，两个为键值对类型</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">values</span><span class="hljs-params">(*args_v)</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> args_v:        print(i)values(<span class="hljs-string">'a'</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<span class="hljs-comment"># 也可以直接是一个列表</span></code></pre><pre><code>a1(1, 2)</code></pre><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kw_values</span><span class="hljs-params">(**kwargs_v)</span>:</span>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs_v.items():        print(k,v)kw_values(name = <span class="hljs-string">'guokai'</span>,age = <span class="hljs-string">'18'</span>)<span class="hljs-comment"># 也可以直接传入字典</span></code></pre><pre><code>name guokaiage 18</code></pre><h2 id="python2和python3的range（100）的区别"><a href="#python2和python3的range（100）的区别" class="headerlink" title="python2和python3的range（100）的区别"></a>python2和python3的range（100）的区别</h2><p>python2返回列表，python3返回迭代器，节约内存</p><h2 id="什么样的语言能够用装饰器"><a href="#什么样的语言能够用装饰器" class="headerlink" title="什么样的语言能够用装饰器?"></a>什么样的语言能够用装饰器?</h2><ul><li>装饰器相当于给原本的函数增加新的功能，常用于鉴权、日志等</li><li>装饰器让你在一个函数的前后去执行代码</li><li>函数可以作为参数传递的语言，可以使用装饰器</li></ul><h3 id="授权-Authorization"><a href="#授权-Authorization" class="headerlink" title="授权(Authorization)"></a>授权(Authorization)</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">requires_auth</span><span class="hljs-params">(f)</span>:</span><span class="hljs-meta">    @wraps(f)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorated</span><span class="hljs-params">(*args, **kwargs)</span>:</span>        auth = request.authorization        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> auth <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> check_auth(auth.username, auth.password):            authenticate()        <span class="hljs-keyword">return</span> f(*args, **kwargs)    <span class="hljs-keyword">return</span> decorated</code></pre><h3 id="日志-Logging"><a href="#日志-Logging" class="headerlink" title="日志(Logging)"></a>日志(Logging)</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logit</span><span class="hljs-params">(func)</span>:</span><span class="hljs-meta">    @wraps(func)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">with_logging</span><span class="hljs-params">(*args, **kwargs)</span>:</span>        print(func.__name__ + <span class="hljs-string">" was called："</span>)        <span class="hljs-keyword">return</span> func(*args, **kwargs)    <span class="hljs-keyword">return</span> with_logging <span class="hljs-meta">@logit</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addition_func</span><span class="hljs-params">(x)</span>:</span>    <span class="hljs-string">"""</span><span class="hljs-string">    Do some math.</span><span class="hljs-string">    """</span>    print(x+x)    <span class="hljs-keyword">return</span> x + x result = addition_func(<span class="hljs-number">4</span>)</code></pre><pre><code>addition_func was called：8</code></pre><h2 id="面向对象中new和init区别"><a href="#面向对象中new和init区别" class="headerlink" title="面向对象中new和init区别"></a>面向对象中<strong>new</strong>和<strong>init</strong>区别</h2><p><code>__init__</code>是初始化方法，创建对象后，就立刻被默认调用了，可接收参数，如下</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bike</span>:</span>    <span class="hljs-string">"""</span><span class="hljs-string">    自行车</span><span class="hljs-string">    :param wheelNum</span><span class="hljs-string">    :param color</span><span class="hljs-string">    :return None</span><span class="hljs-string">    """</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, wheelNum, color)</span>:</span>        self.wheelNum = wheelNum        self.color = color    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">'移动'</span>)<span class="hljs-comment"># 创建对象</span>b = Bike(<span class="hljs-number">2</span>, <span class="hljs-string">'yellow'</span>)print(b.wheelNum, b.color)<span class="hljs-comment"># move方法未执行</span></code></pre><pre><code>2 yellow</code></pre><ul><li><code>__new__</code>至少要有一个参数<code>cls</code>，代表当前类，此参数在实例化时由Python解释器自动识别</li><li><code>__new__</code>必须要有返回值，返回实例化出来的实例，这点在自己实现<code>__new__</code>时要特别注意，可以<code>return</code>父类（通过super(当前类名, cls)）<code>__new__</code>出来的实例，或者直接是object的<code>__new__</code>出来的实例</li><li><code>__init__</code>有一个参数<code>self</code>，就是这个<code>__new__</code>返回的实例，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的动作，<code>__init__</code>不需要返回值</li><li>如果<code>__new__</code>创建的是当前类的实例，会自动调用<code>__init__</code>函数，通过return语句里面调用的<code>__new__</code>函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<code>__init__</code>函数，也不会调用其他类的<code>__init__</code>函数。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">"这是init方法"</span>, self)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, *args, **kwargs)</span>:</span>        print(<span class="hljs-string">'这是cls的ID'</span>, id(cls))        print(<span class="hljs-string">'这是new方法'</span>, object.__new__(cls))        <span class="hljs-keyword">return</span> object.__new__(cls)A()print(<span class="hljs-string">'这是类A的ID'</span>, id(A))</code></pre><pre><code>这是cls的ID 2177705259800这是new方法 &lt;__main__.A object at 0x000001FB0A967240&gt;这是init方法 &lt;__main__.A object at 0x000001FB0A967240&gt;这是类A的ID 2177705259800</code></pre><blockquote><p>cls和类的id一致，说明指向的是同一个类，也就是cls就是创建的实例类</p></blockquote><blockquote><p>init方法中的self和new方法返回的值地址一样，说明返回值是对象</p></blockquote><ul><li><code>__new__</code>分配空间</li><li><code>__init__</code> 对象初始化</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 利用__new__的类属性instance实现单例</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MusicPlayer</span><span class="hljs-params">(object)</span>:</span>     <span class="hljs-comment"># 定义类属性记录创建对象的引用初始值设为None</span>    instance = <span class="hljs-literal">None</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, *args, **kwargs)</span>:</span>        <span class="hljs-comment"># 1.判断类属性是否为None</span>        <span class="hljs-keyword">if</span> cls.instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-comment"># 2.如果对象还没有被创建，就调用父类的方法为第一个对象分配空间</span>            cls.instance = super().__new__(cls)        <span class="hljs-comment"># 3.把类属性中保存的引用返回给Python的解释器</span>        <span class="hljs-keyword">return</span> cls.instance  player1 = MusicPlayer() player2 = MusicPlayer() print(player1)print(player2)</code></pre><pre><code>&lt;__main__.MusicPlayer object at 0x000001FB0A82D080&gt;&lt;__main__.MusicPlayer object at 0x000001FB0A82D080&gt;</code></pre><h2 id="简述with方法打开处理文件帮我我们做了什么？"><a href="#简述with方法打开处理文件帮我我们做了什么？" class="headerlink" title="简述with方法打开处理文件帮我我们做了什么？"></a>简述with方法打开处理文件帮我我们做了什么？</h2><p>打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open</p><p>写法，我们需要try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行finally f.close()关闭文件，with方法帮我们实现了finally中f.close</p><p>（当然还有其他自定义功能，有兴趣可以研究with方法源码）</p><pre><code class="hljs python">f = open(filename,<span class="hljs-string">'wb'</span>)<span class="hljs-keyword">try</span>:    f.write(<span class="hljs-string">'hello'</span>)<span class="hljs-keyword">except</span>:    <span class="hljs-keyword">pass</span><span class="hljs-keyword">finally</span>:    f.close()</code></pre><h2 id="列表-1-2-3-4-5-请使用map-函数输出-1-4-9-16-25-，并使用列表推导式提取出大于10的数，最终输出-16-25"><a href="#列表-1-2-3-4-5-请使用map-函数输出-1-4-9-16-25-，并使用列表推导式提取出大于10的数，最终输出-16-25" class="headerlink" title="列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]"></a>列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]</h2><p>map（）函数第一个参数是fun，第二个参数是一般是list，第三个参数可以写list，也可以不写，根据需求</p><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]list2 = map(<span class="hljs-keyword">lambda</span> x: x * x, list1)<span class="hljs-comment"># list(list2)</span>list3 = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list2 <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">10</span>]list3</code></pre><pre><code>[16, 25]</code></pre><h2 id="避免转义给字符串加哪个字母表示原始字符串？"><a href="#避免转义给字符串加哪个字母表示原始字符串？" class="headerlink" title="避免转义给字符串加哪个字母表示原始字符串？"></a>避免转义给字符串加哪个字母表示原始字符串？</h2><p>使用r,表示需要原始字符，不转义特殊字符</p><pre><code class="hljs python">print(<span class="hljs-string">r'你好！\n郭凯'</span>)</code></pre><pre><code>你好！\n郭凯</code></pre><pre><code class="hljs python">print(<span class="hljs-string">'你好！\n郭凯'</span>)</code></pre><pre><code>你好！郭凯</code></pre><h2 id="python中断言方法举例"><a href="#python中断言方法举例" class="headerlink" title="python中断言方法举例"></a>python中断言方法举例</h2><p><code>Python assert</code>（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。</p><p>断言可以在条件不满足程序运行的情况下直接返回错误，<strong>而不必等待程序运行后出现崩溃的情况</strong>，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。</p><pre><code class="hljs python">a = <span class="hljs-number">3</span><span class="hljs-keyword">assert</span>(a&gt;<span class="hljs-number">1</span>)print(<span class="hljs-string">"断言成功，程序继续向下执行"</span>)</code></pre><pre><code>断言成功，程序继续向下执行</code></pre><pre><code class="hljs python">a = <span class="hljs-number">3</span><span class="hljs-keyword">assert</span>(a&lt;<span class="hljs-number">1</span>)print(<span class="hljs-string">"断言失败，程序报错"</span>)</code></pre><pre><code>---------------------------------------------------------------------------AssertionError                            Traceback (most recent call last)&lt;ipython-input-39-074757426279&gt; in &lt;module&gt;      1 a = 3----&gt; 2 assert(a&lt;1)      3 print(&quot;断言失败，程序报错&quot;)AssertionError: </code></pre><h2 id="列出python中可变数据类型和不可变数据类型，并简述原理"><a href="#列出python中可变数据类型和不可变数据类型，并简述原理" class="headerlink" title="列出python中可变数据类型和不可变数据类型，并简述原理"></a>列出python中可变数据类型和不可变数据类型，并简述原理</h2><p>不可变数据类型：数值型、字符串型string和元组tuple</p><p>不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id</p><pre><code class="hljs python">a = <span class="hljs-number">3</span>b = <span class="hljs-number">3</span><span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> b:    print(<span class="hljs-literal">True</span>)</code></pre><pre><code>True</code></pre><pre><code class="hljs python">id(a)</code></pre><pre><code>140711231656832</code></pre><pre><code class="hljs python">id(b)</code></pre><pre><code>140711231656832</code></pre><p>可变数据类型：列表list和字典dict；</p><p>允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p><pre><code class="hljs python">c = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]d = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> d:    print(<span class="hljs-literal">True</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-literal">False</span>)</code></pre><pre><code>False</code></pre><pre><code class="hljs python">id(c)</code></pre><pre><code>2177725517896</code></pre><pre><code class="hljs python">id(d)</code></pre><pre><code>2177724661704</code></pre><h2 id="s-“ajldjlajfdljfddd”，去重并从小到大排序输出”adfjl”"><a href="#s-“ajldjlajfdljfddd”，去重并从小到大排序输出”adfjl”" class="headerlink" title="s = “ajldjlajfdljfddd”，去重并从小到大排序输出”adfjl”"></a>s = “ajldjlajfdljfddd”，去重并从小到大排序输出”adfjl”</h2><p>set去重，去重转成list,利用sort方法排序，reeverse=False是从小到大排</p><p>list是不 变数据类型，s.sort时候没有返回值，所以注释的代码写法不正确</p><pre><code class="hljs python">s = <span class="hljs-string">"ajldjlajfdljfddd"</span>s = set(s)s = list(s)s.sort()res = <span class="hljs-string">""</span>.join(s)print(res)</code></pre><pre><code>adfjl</code></pre><blockquote><p>join()函数</p></blockquote><blockquote><p>语法：  ‘sep’.join(seq)</p></blockquote><blockquote><p>参数说明</p></blockquote><blockquote><p>sep：分隔符。可以为空</p></blockquote><blockquote><p>seq：要连接的元素序列、字符串、元组、字典</p></blockquote><blockquote><p>上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串</p></blockquote><blockquote><p>返回值：返回一个以分隔符sep连接各个元素后生成的字符串</p></blockquote><h2 id="字典根据键从小到大排序"><a href="#字典根据键从小到大排序" class="headerlink" title="字典根据键从小到大排序"></a>字典根据键从小到大排序</h2><pre><code class="hljs python">sorted.__doc__</code></pre><pre><code>&apos;Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order.&apos;</code></pre><p>sorted可以直接给键排序，返回键的列表</p><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">"name"</span>: <span class="hljs-string">"zs"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">18</span>, <span class="hljs-string">"city"</span>: <span class="hljs-string">"深圳"</span>, <span class="hljs-string">"tel"</span>: <span class="hljs-string">"1362626627"</span>&#125;print(dict1)list1 = sorted(dict1)print(list1)</code></pre><pre><code>{&apos;name&apos;: &apos;zs&apos;, &apos;age&apos;: 18, &apos;city&apos;: &apos;深圳&apos;, &apos;tel&apos;: &apos;1362626627&apos;}[&apos;age&apos;, &apos;city&apos;, &apos;name&apos;, &apos;tel&apos;]</code></pre><pre><code class="hljs python">new_dict = &#123;&#125;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list1:    new_dict[i] = dict1[i]print(new_dict)</code></pre><pre><code>{&apos;age&apos;: 18, &apos;city&apos;: &apos;深圳&apos;, &apos;name&apos;: &apos;zs&apos;, &apos;tel&apos;: &apos;1362626627&apos;}</code></pre><h2 id="利用collections库的Counter方法统计字符串每个单词出现的次数”kjalfj-ldsjafl-hdsllfdhg-lahfbl-hl-ahlf-h”"><a href="#利用collections库的Counter方法统计字符串每个单词出现的次数”kjalfj-ldsjafl-hdsllfdhg-lahfbl-hl-ahlf-h”" class="headerlink" title="利用collections库的Counter方法统计字符串每个单词出现的次数”kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h”"></a>利用collections库的Counter方法统计字符串每个单词出现的次数”kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h”</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Countera = <span class="hljs-string">"kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"</span>res = Counter(a)print(res)</code></pre><pre><code>Counter({&apos;l&apos;: 9, &apos;;&apos;: 6, &apos;h&apos;: 6, &apos;f&apos;: 5, &apos;a&apos;: 4, &apos;j&apos;: 3, &apos;d&apos;: 3, &apos;s&apos;: 2, &apos;k&apos;: 1, &apos;g&apos;: 1, &apos;b&apos;: 1})</code></pre><h2 id="filter方法求出列表所有奇数并构造新列表，a-1-2-3-4-5-6-7-8-9-10"><a href="#filter方法求出列表所有奇数并构造新列表，a-1-2-3-4-5-6-7-8-9-10" class="headerlink" title="filter方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"></a>filter方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</h2><p>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表</p><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fn</span><span class="hljs-params">(a)</span>:</span>    <span class="hljs-keyword">return</span> a%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>b = filter(fn,a)print(list(b))</code></pre><pre><code>[2, 4, 6, 8, 10]</code></pre><h2 id="正则re-complie作用"><a href="#正则re-complie作用" class="headerlink" title="正则re.complie作用"></a>正则re.complie作用</h2><p>re.compile是将正则表达式编译成一个对象，加快速度，并重复使用</p><h2 id="数据库优化查询方法"><a href="#数据库优化查询方法" class="headerlink" title="数据库优化查询方法"></a>数据库优化查询方法</h2><p>外键、索引、联合查询、选择特定字段等等</p><h2 id="写一段自定义异常代码"><a href="#写一段自定义异常代码" class="headerlink" title="写一段自定义异常代码"></a>写一段自定义异常代码</h2><p>自定义异常用raise抛出异常</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):            <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">2</span>:                <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"数字大于二了"</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ret:        print(ret)</code></pre><pre><code class="hljs python">fn()</code></pre><pre><code>数字大于二了</code></pre><h2 id="正则表达式匹配中，（-）和（-）匹配区别？"><a href="#正则表达式匹配中，（-）和（-）匹配区别？" class="headerlink" title="正则表达式匹配中，（.）和（.?）匹配区别？"></a>正则表达式匹配中，（.<em>）和（.</em>?）匹配区别？</h2><p>（.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配</p><p>（.*?）是非贪婪匹配，会把满足正则的尽可能少匹配</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> res = <span class="hljs-string">'&lt;a&gt;哈哈&lt;/a&gt;&lt;a&gt;呵呵&lt;/a&gt;'</span>res1 = re.findall(<span class="hljs-string">'&lt;a&gt;(.*)&lt;/a&gt;'</span>,s)print(<span class="hljs-string">'贪婪匹配'</span>,res1)res2 = re.findall(<span class="hljs-string">'&lt;a&gt;(.*?)&lt;/a&gt;'</span>,s)print(<span class="hljs-string">'非贪婪匹配'</span>,res2)</code></pre><pre><code>贪婪匹配 [&apos;哈哈&lt;/a&gt;&lt;a&gt;呵呵&apos;]非贪婪匹配 [&apos;哈哈&apos;, &apos;呵呵&apos;]</code></pre><h2 id="简述Django的orm"><a href="#简述Django的orm" class="headerlink" title="简述Django的orm"></a>简述Django的orm</h2><p> ORM，全拼Object-Relation Mapping，意为对象-关系映射</p><p>实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改代码只需要面向对象编程,orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句,所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite….，如果数据库迁移，只需要更换Django的数据库引擎即可</p><p><img src="/2020/06/10/ython%E7%BB%8F%E5%85%B8%E9%A2%98/640.png" srcset="/img/loading.gif" alt="jupyter"></p><h2 id="1-2-3-4-5-6-一行代码展开该列表，得出-1-2-3-4-5-6"><a href="#1-2-3-4-5-6-一行代码展开该列表，得出-1-2-3-4-5-6" class="headerlink" title="[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]"></a>[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</h2><ul><li>列表推导式</li><li>numpy的flatten()方法，仅支出numpy类型</li></ul><pre><code class="hljs python">a = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]x = [j <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i]x</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npb = np.array(a).flatten().tolist()b</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><blockquote><p>flatten()函数仅支持规则的二维数组</p></blockquote><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npc = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]d = np.array(c).flatten().tolist()print(d)</code></pre><pre><code>[[1, 2, 3, 4], [1, 2, 4], [1, 2, 3, 4]]</code></pre><h2 id="x-”abc”-y-”def”-z-“d”-”e”-”f”-分别求出x-join-y-和x-join-z-返回的结果"><a href="#x-”abc”-y-”def”-z-“d”-”e”-”f”-分别求出x-join-y-和x-join-z-返回的结果" class="headerlink" title="x=”abc”,y=”def”,z=[“d”,”e”,”f”],分别求出x.join(y)和x.join(z)返回的结果"></a>x=”abc”,y=”def”,z=[“d”,”e”,”f”],分别求出x.join(y)和x.join(z)返回的结果</h2><p>join()括号里面的是可迭代对象，x插入可迭代对象中间，形成字符串，结果一致，有没有突然感觉字符串的常见操作都不会玩了</p><p>顺便建议大家学下os.path.join()方法，拼接路径经常用到，也用到了join,和字符串操作中的join有什么区别，该问题大家可以查阅相关文档，后期会有答案</p><pre><code class="hljs python">x = <span class="hljs-string">"abc"</span>y = <span class="hljs-string">"def"</span>z = [<span class="hljs-string">"d"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"f"</span>]m = x.join(y)n = x.join(z)print(m)print(n)</code></pre><pre><code>dabceabcfdabceabcf</code></pre><h2 id="举例说明zip（）函数用法-——常用于快速生成字典"><a href="#举例说明zip（）函数用法-——常用于快速生成字典" class="headerlink" title="举例说明zip（）函数用法 ——常用于快速生成字典"></a>举例说明zip（）函数用法 ——常用于快速生成字典</h2><p>zip()函数在运算时，会以一个或多个序列（可迭代对象）做为参数，返回一个元组的列表。同时将这些序列中并排的元素配对。</p><p>zip()参数可以接受任何类型的序列，同时也可以有两个以上的参数;当传入参数的长度不同时，zip能自动以最短序列长度为准进行截取，获得元组。</p><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]b = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]c = dict(zip(a, b))print(c)</code></pre><pre><code>{1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;}</code></pre><h2 id="提高python运行效率的方法"><a href="#提高python运行效率的方法" class="headerlink" title="提高python运行效率的方法"></a>提高python运行效率的方法</h2><p>1、使用生成器，因为可以节约大量内存</p><p>2、循环代码优化，避免过多重复代码的执行</p><p>3、核心模块用Cython  PyPy等，提高效率</p><p>4、多进程、多线程、协程</p><p>5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率</p><h2 id="简述mysql和redis区别"><a href="#简述mysql和redis区别" class="headerlink" title="简述mysql和redis区别"></a>简述mysql和redis区别</h2><p>redis： 内存型非关系数据库，数据保存在内存中，速度快</p><p>mysql：关系型数据库，数据保存在磁盘中，检索的话，会有一定的Io操作，访问速度相对慢</p><h2 id="保留两位小数-round-数值，保留位数"><a href="#保留两位小数-round-数值，保留位数" class="headerlink" title="保留两位小数 -round(数值，保留位数)"></a>保留两位小数 -round(数值，保留位数)</h2><pre><code class="hljs python">a =<span class="hljs-number">1.3384532</span>b = round(a,<span class="hljs-number">2</span>)print(b)print(type(b))</code></pre><pre><code>1.34&lt;class &apos;float&apos;&gt;</code></pre><h2 id="列出常见的状态码和意义"><a href="#列出常见的状态码和意义" class="headerlink" title="列出常见的状态码和意义"></a>列出常见的状态码和意义</h2><p><strong>200 OK</strong> </p><p>请求正常处理完毕</p><p>204 No Content </p><p>请求成功处理，没有实体的主体返回</p><p>206 Partial Content </p><p>GET范围请求已成功处理</p><p><strong>301 Moved Permanently</strong></p><p>永久重定向，资源已永久分配新URI</p><p><strong>302 Found</strong></p><p>临时重定向，资源已临时分配新URI</p><p>303 See Other </p><p>临时重定向，期望使用GET定向获取</p><p>304 Not Modified </p><p>发送的附带条件请求未满足</p><p>307 Temporary Redirect </p><p>临时重定向，POST不会变成GET</p><p><strong>400 Bad Request</strong> </p><p>请求报文语法错误或参数错误</p><p>401 Unauthorized </p><p>需要通过HTTP认证，或认证失败</p><p><strong>403 Forbidden</strong> </p><p>请求资源被拒绝</p><p>*<em>404 Not Found *</em></p><p>无法找到请求资源（服务器无理由拒绝）</p><p>*<em>500 Internal Server Error *</em></p><p>服务器故障或Web应用故障</p><p>503 Service Unavailable </p><p>服务器超负载或停机维护</p><h2 id="分别从前端、后端、数据库阐述web项目的性能优化"><a href="#分别从前端、后端、数据库阐述web项目的性能优化" class="headerlink" title="分别从前端、后端、数据库阐述web项目的性能优化"></a>分别从前端、后端、数据库阐述web项目的性能优化</h2><p><strong>前端优化</strong>：</p><p>1、减少http请求、例如制作精灵图（css精灵(CSS sprites),是一种网页图片应用处理技术。主要是指将网页中需要的零星的小图片集成到一个大的图片中）</p><p>2、html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差</p><p><strong>后端优化</strong>：</p><p>1、缓存存储读写次数高，变化少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。</p><p>2、异步方式，如果有耗时操作，可以采用异步，比如celery</p><p>3、代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况</p><p><strong>数据库优化</strong>：</p><p>1、如有条件，数据可以存放于redis，读取速度快</p><p>2、建立索引、外键等</p><h2 id="简述同源策略——跨域问题"><a href="#简述同源策略——跨域问题" class="headerlink" title="简述同源策略——跨域问题"></a>简述同源策略——跨域问题</h2><p>同源策略需要同时满足以下三点要求： </p><p>1）协议相同 </p><p> 2）域名相同 </p><p>3）端口相同 </p><p> http:<a href="http://www.test.com与https:www.test.com">www.test.com与https:www.test.com</a> 不同源——协议不同 </p><p> http:<a href="http://www.test.com与http:www.admin.com">www.test.com与http:www.admin.com</a> 不同源——域名不同 </p><p> http:<a href="http://www.test.com与http:www.test.com:8081">www.test.com与http:www.test.com:8081</a> 不同源——端口不同</p><p> 只要不满足其中任意一个要求，就不符合同源策略，就会出现“跨域”</p><pre><code class="hljs python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
